#pragma version 9

// This TEAL was generated by TEALScript v0.62.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its repsective branch will be "NOT_IMPLMENTED" which just contains "err"
txn ApplicationID
int 0
>
int 6
*
txn OnCompletion
+
switch create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED call_NoOp

NOT_IMPLEMENTED:
	err

// createApplication()void
abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	int 1
	return

createApplication:
	proto 0 0

	// contracts/aurally.algo.ts:77
	// this.aurallyToken.value = Asset.zeroIndex
	byte 0x617572616c6c79546f6b656e // "aurallyToken"
	int 0
	app_global_put
	retsub

pay:
	proto 2 0

	// contracts/aurally.algo.ts:81
	// assert(amount > 0)
	frame_dig -2 // amount: uint64
	int 0
	>
	assert

	// contracts/aurally.algo.ts:82
	// sendPayment({
	//       receiver: receiver,
	//       amount: amount,
	//     })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/aurally.algo.ts:83
	// receiver: receiver
	frame_dig -1 // receiver: account
	itxn_field Receiver

	// contracts/aurally.algo.ts:84
	// amount: amount
	frame_dig -2 // amount: uint64
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// createSoundNFT(string,string,uint64,uint64,string,string,string,string,uint64,string,string,string,account)bool
//
// // Create a new Sound NFT
abi_route_createSoundNFT:
	byte 0x; dupn 3 // push empty bytes to fill the stack frame for this subroutine's local variables

	// audioSampleIpfs: string
	txna ApplicationArgs 13
	extract 2 0

	// coverImageIpfs: string
	txna ApplicationArgs 12
	extract 2 0

	// releaseDate: uint64
	txna ApplicationArgs 11
	btoi

	// price: uint64
	txna ApplicationArgs 10
	btoi

	// genre: string
	txna ApplicationArgs 9
	extract 2 0

	// artist: string
	txna ApplicationArgs 8
	extract 2 0

	// label: string
	txna ApplicationArgs 7
	extract 2 0

	// title: string
	txna ApplicationArgs 6
	extract 2 0

	// supply: uint64
	txna ApplicationArgs 5
	btoi

	// _username: string
	txna ApplicationArgs 4
	extract 2 0

	// _fullname: string
	txna ApplicationArgs 3
	extract 2 0

	// nft: string
	txna ApplicationArgs 2
	extract 2 0

	// creator: account
	txna ApplicationArgs 1
	btoi
	txnas Accounts

	// execute createSoundNFT(string,string,uint64,uint64,string,string,string,string,uint64,string,string,string,account)bool
	callsub createSoundNFT
	int 1
	return

createSoundNFT:
	proto 17 0

	// if0_condition
	// contracts/aurally.algo.ts:105
	// !this.aurallyNFTOwner(this.txn.sender).exists
	byte 0x6e66744f776e6572 // "nftOwner"
	txn Sender
	concat
	box_len
	swap
	pop
	!
	bz if0_end

	// if0_consequent
	// contracts/aurally.algo.ts:107
	// dNft = sendAssetCreation({
	//         configAssetTotal: 1, // D-NFTs are typically unique
	//         configAssetName: rawBytes(creator.authAddr),
	//         configAssetManager: this.app.address, // The contract itself manages the D-NFT
	//       })
	itxn_begin
	int acfg
	itxn_field TypeEnum

	// contracts/aurally.algo.ts:108
	// configAssetTotal: 1
	int 1
	itxn_field ConfigAssetTotal

	// contracts/aurally.algo.ts:109
	// configAssetName: rawBytes(creator.authAddr)
	frame_dig -1 // creator: account
	acct_params_get AcctAuthAddr
	assert
	itxn_field ConfigAssetName

	// contracts/aurally.algo.ts:110
	// configAssetManager: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetManager

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn CreatedAssetID
	frame_bury -14 // dNft: asset

	// contracts/aurally.algo.ts:114
	// this.aurallyNFTOwner(this.txn.sender).value = {
	//         creative_type: 'music', // or 'art', based on context
	//         minted: 0,
	//         fullname: _fullname,
	//         username: _username,
	//         dNft: dNft,
	//       }
	byte 0x6e66744f776e6572 // "nftOwner"
	txn Sender
	concat
	dup
	box_del
	pop
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0016 // initial head offset
	byte 0x00056d75736963
	callsub process_dynamic_tuple_element
	byte 0x0000000000000000
	callsub process_static_tuple_element
	frame_dig -3 // _fullname: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -4 // _username: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -14 // dNft: asset
	itob
	callsub process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	box_put

	// contracts/aurally.algo.ts:122
	// this.dnftH.value = dNft
	byte 0x646e667448 // "dnftH"
	frame_dig -14 // dNft: asset
	app_global_put

if0_end:
	// contracts/aurally.algo.ts:125
	// assert(this.aurallyNFTOwner(this.txn.sender).value.creative_type === 'music')
	byte 0x6e66744f776e6572 // "nftOwner"
	txn Sender
	concat
	box_get
	assert
	store 255 // full array
	int 0
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	byte 0x6d75736963 // "music"
	==
	assert

	// contracts/aurally.algo.ts:126
	// assert(!this.soundNFTs(nft).exists)
	byte 0x736f756e644e4654 // "soundNFT"
	frame_dig -2 // nft: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_len
	swap
	pop
	!
	assert

	// contracts/aurally.algo.ts:129
	// assert(!this.usedIpfsHashes(nft).exists)
	byte 0x69706673486173686573 // "ipfsHashes"
	frame_dig -2 // nft: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_len
	swap
	pop
	!
	assert

	// contracts/aurally.algo.ts:132
	// soundnft = sendAssetCreation({
	//       configAssetTotal: supply,
	//       configAssetMetadataHash: nft,
	//       configAssetURL: 'https://ipfs.io/ipfs/' + nft,
	//       configAssetName: nft,
	//     })
	itxn_begin
	int acfg
	itxn_field TypeEnum

	// contracts/aurally.algo.ts:133
	// configAssetTotal: supply
	frame_dig -5 // supply: uint64
	itxn_field ConfigAssetTotal

	// contracts/aurally.algo.ts:134
	// configAssetMetadataHash: nft
	frame_dig -2 // nft: bytes
	itxn_field ConfigAssetMetadataHash

	// contracts/aurally.algo.ts:135
	// configAssetURL: 'https://ipfs.io/ipfs/' + nft
	byte 0x68747470733a2f2f697066732e696f2f697066732f // "https://ipfs.io/ipfs/"
	frame_dig -2 // nft: bytes
	concat
	itxn_field ConfigAssetURL

	// contracts/aurally.algo.ts:136
	// configAssetName: nft
	frame_dig -2 // nft: bytes
	itxn_field ConfigAssetName

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn CreatedAssetID
	frame_bury -15 // soundnft: asset

	// contracts/aurally.algo.ts:139
	// this.soundNFTs(nft).value = {
	//       AssetName: soundnft.id,
	//       title: title,
	//       label: label,
	//       artist: artist,
	//       releaseDate: releaseDate,
	//       genre: genre,
	//       price: price,
	//       coverImageIpfs: coverImageIpfs,
	//       audioSampleIpfs: audioSampleIpfs,
	//       fullTrackIpfs: nft,
	//       owner: this.txn.sender,
	//       supply: supply,
	//       forSale: true,
	//     }
	byte 0x736f756e644e4654 // "soundNFT"
	frame_dig -2 // nft: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	dup
	box_del
	pop
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x004f // initial head offset
	frame_dig -15 // soundnft: asset
	itob
	callsub process_static_tuple_element
	frame_dig -5 // supply: uint64
	itob
	callsub process_static_tuple_element
	frame_dig -6 // title: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -7 // label: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -8 // artist: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -11 // releaseDate: uint64
	itob
	callsub process_static_tuple_element
	frame_dig -9 // genre: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -10 // price: uint64
	itob
	callsub process_static_tuple_element
	frame_dig -12 // coverImageIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -13 // audioSampleIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -2 // nft: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	txn Sender
	callsub process_static_tuple_element
	byte 0x00
	int 0
	int 1
	setbit
	callsub process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	box_put

	// contracts/aurally.algo.ts:155
	// this.usedIpfsHashes(nft).value = true
	byte 0x69706673486173686573 // "ipfsHashes"
	frame_dig -2 // nft: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	int 1
	byte 0x00
	int 0
	uncover 2
	setbit
	box_put

	// contracts/aurally.algo.ts:158
	// creatorData = this.aurallyNFTOwner(creator.authAddr).value
	byte 0x6e66744f776e6572 // "nftOwner"
	frame_dig -1 // creator: account
	acct_params_get AcctAuthAddr
	assert
	concat
	frame_bury -16 // storage key//creatorData

	// contracts/aurally.algo.ts:159
	// incr = creatorData.minted + 1
	frame_dig -16 // storage key//creatorData
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 2 8
	btoi
	int 1
	+
	frame_bury -17 // incr: uint64

	// contracts/aurally.algo.ts:160
	// this.aurallyNFTOwner(this.txn.sender).value = {
	//       creative_type: 'music', // or 'art', based on context
	//       minted: incr,
	//       fullname: _fullname,
	//       username: _username,
	//       dNft: this.dnftH.value,
	//     }
	byte 0x6e66744f776e6572 // "nftOwner"
	txn Sender
	concat
	dup
	box_del
	pop
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0016 // initial head offset
	byte 0x00056d75736963
	callsub process_dynamic_tuple_element
	frame_dig -17 // incr: uint64
	itob
	callsub process_static_tuple_element
	frame_dig -3 // _fullname: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -4 // _username: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	byte 0x646e667448 // "dnftH"
	app_global_get
	itob
	callsub process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	box_put

	// contracts/aurally.algo.ts:168
	// return true;
	int 1
	byte 0x00
	int 0
	uncover 2
	setbit
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// createArtNFT(string,string,(string,uint64,string,uint64,string,string,uint64,uint64,address,bool),account)bool
//
// // Create a new Art NFT
abi_route_createArtNFT:
	byte 0x; dupn 3 // push empty bytes to fill the stack frame for this subroutine's local variables

	// _username: string
	txna ApplicationArgs 4
	extract 2 0

	// _fullname: string
	txna ApplicationArgs 3
	extract 2 0

	// nft: { title: string; AssetName: uint64; name: string; supply: uint64; description: string; ipfslocation: string; price: uint64; soldPrice: uint64; owner: Address; forSale: boolean; }
	txna ApplicationArgs 2

	// creator: account
	txna ApplicationArgs 1
	btoi
	txnas Accounts

	// execute createArtNFT(string,string,(string,uint64,string,uint64,string,string,uint64,uint64,address,bool),account)bool
	callsub createArtNFT
	int 1
	return

createArtNFT:
	proto 8 0

	// if1_condition
	// contracts/aurally.algo.ts:174
	// !this.aurallyNFTOwner(this.txn.sender).exists
	byte 0x6e66744f776e6572 // "nftOwner"
	txn Sender
	concat
	box_len
	swap
	pop
	!
	bz if1_end

	// if1_consequent
	// contracts/aurally.algo.ts:176
	// dNft = sendAssetCreation({
	//         configAssetTotal: 1, // D-NFTs are typically unique
	//         configAssetName: rawBytes(creator.authAddr),
	//         configAssetManager: this.app.address, // The contract itself manages the D-NFT
	//       })
	itxn_begin
	int acfg
	itxn_field TypeEnum

	// contracts/aurally.algo.ts:177
	// configAssetTotal: 1
	int 1
	itxn_field ConfigAssetTotal

	// contracts/aurally.algo.ts:178
	// configAssetName: rawBytes(creator.authAddr)
	frame_dig -1 // creator: account
	acct_params_get AcctAuthAddr
	assert
	itxn_field ConfigAssetName

	// contracts/aurally.algo.ts:179
	// configAssetManager: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetManager

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn CreatedAssetID
	frame_bury -5 // dNft: asset

	// contracts/aurally.algo.ts:183
	// this.aurallyNFTOwner(creator.authAddr).value = {
	//         creative_type: 'art',
	//         minted: 0,
	//         fullname: _fullname,
	//         username: _username,
	//         dNft: dNft,
	//       }
	byte 0x6e66744f776e6572 // "nftOwner"
	frame_dig -1 // creator: account
	acct_params_get AcctAuthAddr
	assert
	concat
	dup
	box_del
	pop
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0016 // initial head offset
	byte 0x0003617274
	callsub process_dynamic_tuple_element
	byte 0x0000000000000000
	callsub process_static_tuple_element
	frame_dig -3 // _fullname: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -4 // _username: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -5 // dNft: asset
	itob
	callsub process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	box_put

if1_end:
	// contracts/aurally.algo.ts:192
	// assert(this.aurallyNFTOwner(creator.authAddr).value.creative_type === 'art')
	byte 0x6e66744f776e6572 // "nftOwner"
	frame_dig -1 // creator: account
	acct_params_get AcctAuthAddr
	assert
	concat
	box_get
	assert
	store 255 // full array
	int 0
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	byte 0x617274 // "art"
	==
	assert

	// contracts/aurally.algo.ts:193
	// assert(!this.aurallyNFTOwner(creator.authAddr).exists)
	byte 0x6e66744f776e6572 // "nftOwner"
	frame_dig -1 // creator: account
	acct_params_get AcctAuthAddr
	assert
	concat
	box_len
	swap
	pop
	!
	assert

	// contracts/aurally.algo.ts:194
	// assert(!this.soundNFTs(nft.ipfslocation).exists)
	byte 0x736f756e644e4654 // "soundNFT"
	frame_dig -2 // nft: { title: string; AssetName: uint64; name: string; supply: uint64; description: string; ipfslocation: string; price: uint64; soldPrice: uint64; owner: Address; forSale: boolean; }
	store 255 // full array
	int 22
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_len
	swap
	pop
	!
	assert

	// contracts/aurally.algo.ts:196
	// artnft = sendAssetCreation({
	//       configAssetTotal: nft.supply,
	//       configAssetMetadataHash: nft.ipfslocation,
	//       configAssetURL: 'https://ipfs.io/ipfs/' + nft.ipfslocation,
	//       configAssetName: nft.ipfslocation,
	//     })
	itxn_begin
	int acfg
	itxn_field TypeEnum

	// contracts/aurally.algo.ts:197
	// configAssetTotal: nft.supply
	frame_dig -2 // nft: { title: string; AssetName: uint64; name: string; supply: uint64; description: string; ipfslocation: string; price: uint64; soldPrice: uint64; owner: Address; forSale: boolean; }
	store 255 // full array
	load 255 // full array
	extract 12 8
	btoi
	itxn_field ConfigAssetTotal

	// contracts/aurally.algo.ts:198
	// configAssetMetadataHash: nft.ipfslocation
	frame_dig -2 // nft: { title: string; AssetName: uint64; name: string; supply: uint64; description: string; ipfslocation: string; price: uint64; soldPrice: uint64; owner: Address; forSale: boolean; }
	store 255 // full array
	int 22
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	itxn_field ConfigAssetMetadataHash

	// contracts/aurally.algo.ts:199
	// configAssetURL: 'https://ipfs.io/ipfs/' + nft.ipfslocation
	byte 0x68747470733a2f2f697066732e696f2f697066732f // "https://ipfs.io/ipfs/"
	frame_dig -2 // nft: { title: string; AssetName: uint64; name: string; supply: uint64; description: string; ipfslocation: string; price: uint64; soldPrice: uint64; owner: Address; forSale: boolean; }
	store 255 // full array
	int 22
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	concat
	itxn_field ConfigAssetURL

	// contracts/aurally.algo.ts:200
	// configAssetName: nft.ipfslocation
	frame_dig -2 // nft: { title: string; AssetName: uint64; name: string; supply: uint64; description: string; ipfslocation: string; price: uint64; soldPrice: uint64; owner: Address; forSale: boolean; }
	store 255 // full array
	int 22
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	itxn_field ConfigAssetName

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn CreatedAssetID
	frame_bury -6 // artnft: asset

	// contracts/aurally.algo.ts:203
	// this.artNFTs(nft.ipfslocation).value = {
	//       AssetName: artnft.id,
	//       title: nft.title,
	//       name: nft.name,
	//       supply: nft.supply,
	//       description: nft.description,
	//       ipfslocation: nft.ipfslocation,
	//       price: nft.price, // Initial bid price
	//       soldPrice: 0, // Initial sold price
	//       owner: creator.authAddr, // NFT initially owned by creator
	//       forSale: true, // Listed for sale by default
	//     }
	byte 0x6172744e4654 // "artNFT"
	frame_dig -2 // nft: { title: string; AssetName: uint64; name: string; supply: uint64; description: string; ipfslocation: string; price: uint64; soldPrice: uint64; owner: Address; forSale: boolean; }
	store 255 // full array
	int 22
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	dup
	box_del
	pop
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0049 // initial head offset
	frame_dig -2 // nft: { title: string; AssetName: uint64; name: string; supply: uint64; description: string; ipfslocation: string; price: uint64; soldPrice: uint64; owner: Address; forSale: boolean; }
	store 255 // full array
	int 0
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -6 // artnft: asset
	itob
	callsub process_static_tuple_element
	frame_dig -2 // nft: { title: string; AssetName: uint64; name: string; supply: uint64; description: string; ipfslocation: string; price: uint64; soldPrice: uint64; owner: Address; forSale: boolean; }
	store 255 // full array
	int 10
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -2 // nft: { title: string; AssetName: uint64; name: string; supply: uint64; description: string; ipfslocation: string; price: uint64; soldPrice: uint64; owner: Address; forSale: boolean; }
	store 255 // full array
	load 255 // full array
	extract 12 8
	btoi
	itob
	callsub process_static_tuple_element
	frame_dig -2 // nft: { title: string; AssetName: uint64; name: string; supply: uint64; description: string; ipfslocation: string; price: uint64; soldPrice: uint64; owner: Address; forSale: boolean; }
	store 255 // full array
	int 20
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -2 // nft: { title: string; AssetName: uint64; name: string; supply: uint64; description: string; ipfslocation: string; price: uint64; soldPrice: uint64; owner: Address; forSale: boolean; }
	store 255 // full array
	int 22
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -2 // nft: { title: string; AssetName: uint64; name: string; supply: uint64; description: string; ipfslocation: string; price: uint64; soldPrice: uint64; owner: Address; forSale: boolean; }
	store 255 // full array
	load 255 // full array
	extract 24 8
	btoi
	itob
	callsub process_static_tuple_element
	byte 0x0000000000000000
	callsub process_static_tuple_element
	frame_dig -1 // creator: account
	acct_params_get AcctAuthAddr
	assert
	callsub process_static_tuple_element
	byte 0x00
	int 0
	int 1
	setbit
	callsub process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	box_put

	// contracts/aurally.algo.ts:217
	// this.artAuctions(nft.ipfslocation).value = {
	//       nftHash: nft.ipfslocation,
	//       nftName: nft.name,
	//       minBid: nft.price,
	//       highestBid: 0,
	//       highestBidder: globals.zeroAddress,
	//       isAuctionActive: true,
	//     }
	frame_dig -2 // nft: { title: string; AssetName: uint64; name: string; supply: uint64; description: string; ipfslocation: string; price: uint64; soldPrice: uint64; owner: Address; forSale: boolean; }
	store 255 // full array
	int 22
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	dup
	box_del
	pop
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0035 // initial head offset
	frame_dig -2 // nft: { title: string; AssetName: uint64; name: string; supply: uint64; description: string; ipfslocation: string; price: uint64; soldPrice: uint64; owner: Address; forSale: boolean; }
	store 255 // full array
	int 22
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -2 // nft: { title: string; AssetName: uint64; name: string; supply: uint64; description: string; ipfslocation: string; price: uint64; soldPrice: uint64; owner: Address; forSale: boolean; }
	store 255 // full array
	int 10
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -2 // nft: { title: string; AssetName: uint64; name: string; supply: uint64; description: string; ipfslocation: string; price: uint64; soldPrice: uint64; owner: Address; forSale: boolean; }
	store 255 // full array
	load 255 // full array
	extract 24 8
	btoi
	itob
	callsub process_static_tuple_element
	byte 0x0000000000000000
	callsub process_static_tuple_element
	global ZeroAddress
	callsub process_static_tuple_element
	byte 0x00
	int 0
	int 1
	setbit
	callsub process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	box_put

	// contracts/aurally.algo.ts:227
	// creatorData = this.aurallyNFTOwner(creator.authAddr).value
	byte 0x6e66744f776e6572 // "nftOwner"
	frame_dig -1 // creator: account
	acct_params_get AcctAuthAddr
	assert
	concat
	frame_bury -7 // storage key//creatorData

	// contracts/aurally.algo.ts:228
	// incr = creatorData.minted + 1
	frame_dig -7 // storage key//creatorData
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 2 8
	btoi
	int 1
	+
	frame_bury -8 // incr: uint64

	// contracts/aurally.algo.ts:229
	// this.aurallyNFTOwner(this.txn.sender).value = {
	//       creative_type: 'art', // or 'art', based on context
	//       minted: incr,
	//       fullname: _fullname,
	//       username: _username,
	//       dNft: this.dnftH.value,
	//     }
	byte 0x6e66744f776e6572 // "nftOwner"
	txn Sender
	concat
	dup
	box_del
	pop
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0016 // initial head offset
	byte 0x0003617274
	callsub process_dynamic_tuple_element
	frame_dig -8 // incr: uint64
	itob
	callsub process_static_tuple_element
	frame_dig -3 // _fullname: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -4 // _username: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	byte 0x646e667448 // "dnftH"
	app_global_get
	itob
	callsub process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	box_put

	// contracts/aurally.algo.ts:236
	// return true;
	int 1
	byte 0x00
	int 0
	uncover 2
	setbit
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// startAuction(uint64,string,string)void
abi_route_startAuction:
	// minBid: uint64
	txna ApplicationArgs 3
	btoi

	// nftName: string
	txna ApplicationArgs 2
	extract 2 0

	// nftIpfs: string
	txna ApplicationArgs 1
	extract 2 0

	// execute startAuction(uint64,string,string)void
	callsub startAuction
	int 1
	return

startAuction:
	proto 3 0

	// contracts/aurally.algo.ts:247
	// this.artAuctions(nftIpfs).value = {
	//       nftHash: nftIpfs,
	//       nftName: nftName,
	//       minBid: minBid,
	//       highestBid: 0,
	//       highestBidder: globals.zeroAddress,
	//       isAuctionActive: true,
	//     }
	frame_dig -1 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	dup
	box_del
	pop
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0035 // initial head offset
	frame_dig -1 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -2 // nftName: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -3 // minBid: uint64
	itob
	callsub process_static_tuple_element
	byte 0x0000000000000000
	callsub process_static_tuple_element
	global ZeroAddress
	callsub process_static_tuple_element
	byte 0x00
	int 0
	int 1
	setbit
	callsub process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	box_put
	retsub

// bidOnArtAuction(uint64,string,account)void
abi_route_bidOnArtAuction:
	byte 0x; dup // push empty bytes to fill the stack frame for this subroutine's local variables

	// bidAmount: uint64
	txna ApplicationArgs 3
	btoi

	// nftIpfs: string
	txna ApplicationArgs 2
	extract 2 0

	// bidder: account
	txna ApplicationArgs 1
	btoi
	txnas Accounts

	// execute bidOnArtAuction(uint64,string,account)void
	callsub bidOnArtAuction
	int 1
	return

bidOnArtAuction:
	proto 5 0

	// contracts/aurally.algo.ts:258
	// auctionExists = this.artAuctions(nftIpfs).exists
	frame_dig -2 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_len
	swap
	pop
	frame_bury -4 // auctionExists: uint64

	// contracts/aurally.algo.ts:259
	// assert(auctionExists)
	frame_dig -4 // auctionExists: uint64
	assert

	// if2_condition
	// contracts/aurally.algo.ts:261
	// auctionExists
	frame_dig -4 // auctionExists: uint64
	bz if2_end

	// if2_consequent
	// contracts/aurally.algo.ts:262
	// auction = this.artAuctions(nftIpfs).value
	frame_dig -2 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	frame_bury -5 // storage key//auction

	// contracts/aurally.algo.ts:265
	// assert(bidAmount > auction.highestBid)
	frame_dig -3 // bidAmount: uint64
	frame_dig -5 // storage key//auction
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 12 8
	btoi
	>
	assert

	// contracts/aurally.algo.ts:268
	// auction.highestBid = bidAmount
	frame_dig -5 // storage key//auction
	box_get
	assert
	store 255 // full array
	load 255 // full array
	int 12
	frame_dig -3 // bidAmount: uint64
	itob
	replace3
	frame_dig -5 // storage key//auction
	dup
	box_del
	pop
	swap
	box_put

	// contracts/aurally.algo.ts:269
	// auction.highestBidder = bidder.authAddr
	frame_dig -5 // storage key//auction
	box_get
	assert
	store 255 // full array
	load 255 // full array
	int 20
	frame_dig -1 // bidder: account
	acct_params_get AcctAuthAddr
	assert
	replace3
	frame_dig -5 // storage key//auction
	dup
	box_del
	pop
	swap
	box_put

	// contracts/aurally.algo.ts:270
	// this.artAuctions(nftIpfs).value = auction
	frame_dig -2 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	dup
	box_del
	pop
	frame_dig -5 // storage key//auction
	box_get
	assert
	box_put

if2_end:
	retsub

// endArtAuction(string,account)void
abi_route_endArtAuction:
	byte 0x; dup // push empty bytes to fill the stack frame for this subroutine's local variables

	// nftIpfs: string
	txna ApplicationArgs 2
	extract 2 0

	// seller: account
	txna ApplicationArgs 1
	btoi
	txnas Accounts

	// execute endArtAuction(string,account)void
	callsub endArtAuction
	int 1
	return

endArtAuction:
	proto 4 0

	// contracts/aurally.algo.ts:275
	// auction = this.artAuctions(nftIpfs).value
	frame_dig -2 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	frame_bury -3 // storage key//auction

	// contracts/aurally.algo.ts:276
	// assert(this.artAuctions(nftIpfs).exists)
	frame_dig -2 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_len
	swap
	pop
	assert

	// contracts/aurally.algo.ts:277
	// assert(this.artNFTs(nftIpfs).value.owner === seller.authAddr)
	byte 0x6172744e4654 // "artNFT"
	frame_dig -2 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 40 32
	frame_dig -1 // seller: account
	acct_params_get AcctAuthAddr
	assert
	==
	assert

	// contracts/aurally.algo.ts:281
	// nft = this.artNFTs(nftIpfs).value
	byte 0x6172744e4654 // "artNFT"
	frame_dig -2 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	frame_bury -4 // storage key//nft

	// contracts/aurally.algo.ts:282
	// nft.owner = auction.highestBidder
	frame_dig -4 // storage key//nft
	box_get
	assert
	store 255 // full array
	load 255 // full array
	int 40
	frame_dig -3 // storage key//auction
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 20 32
	replace3
	frame_dig -4 // storage key//nft
	dup
	box_del
	pop
	swap
	box_put

	// contracts/aurally.algo.ts:283
	// this.artNFTs(nftIpfs).value.owner = nft.owner
	byte 0x6172744e4654 // "artNFT"
	frame_dig -2 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get
	assert
	store 255 // full array
	load 255 // full array
	int 40
	frame_dig -4 // storage key//nft
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 40 32
	replace3
	byte 0x6172744e4654 // "artNFT"
	frame_dig -2 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	dup
	box_del
	pop
	swap
	box_put
	retsub

// purchaseNFT(bool,string,account)bool
//
// // // Purchase an NFT
abi_route_purchaseNFT:
	// isSoundNFT: bool
	txna ApplicationArgs 3
	dup
	len
	int 1
	==
	assert
	int 0
	getbit

	// nftIpfs: string
	txna ApplicationArgs 2
	extract 2 0

	// buyer: account
	txna ApplicationArgs 1
	btoi
	txnas Accounts

	// execute purchaseNFT(bool,string,account)bool
	callsub purchaseNFT
	int 1
	return

purchaseNFT:
	proto 3 0

	// if3_condition
	// contracts/aurally.algo.ts:292
	// isSoundNFT ? this.soundNFTs(nftIpfs).exists : this.artNFTs(nftIpfs).exists
	frame_dig -3 // isSoundNFT: bool
	bz ternary0_false
	byte 0x736f756e644e4654 // "soundNFT"
	frame_dig -2 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_len
	swap
	pop
	b ternary0_end

ternary0_false:
	byte 0x6172744e4654 // "artNFT"
	frame_dig -2 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_len
	swap
	pop

ternary0_end:
	bz if3_else

	// if3_consequent
	// contracts/aurally.algo.ts:293
	// this.soundNFTs(nftIpfs).value.owner = buyer.authAddr
	byte 0x736f756e644e4654 // "soundNFT"
	frame_dig -2 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get
	assert
	store 255 // full array
	load 255 // full array
	int 46
	frame_dig -1 // buyer: account
	acct_params_get AcctAuthAddr
	assert
	replace3
	byte 0x736f756e644e4654 // "soundNFT"
	frame_dig -2 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	dup
	box_del
	pop
	swap
	box_put

	// contracts/aurally.algo.ts:295
	// assert(this.soundNFTs(nftIpfs).value.owner !== buyer.authAddr)
	byte 0x736f756e644e4654 // "soundNFT"
	frame_dig -2 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 46 32
	frame_dig -1 // buyer: account
	acct_params_get AcctAuthAddr
	assert
	!=
	assert

	// contracts/aurally.algo.ts:297
	// this.pay(this.soundNFTs(nftIpfs).value.owner, this.soundNFTs(nftIpfs).value.price)
	byte 0x736f756e644e4654 // "soundNFT"
	frame_dig -2 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 32 8
	btoi
	byte 0x736f756e644e4654 // "soundNFT"
	frame_dig -2 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 46 32
	callsub pay
	b if3_end

if3_else:
	// contracts/aurally.algo.ts:299
	// this.artNFTs(nftIpfs).value.owner = buyer.authAddr
	byte 0x6172744e4654 // "artNFT"
	frame_dig -2 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get
	assert
	store 255 // full array
	load 255 // full array
	int 40
	frame_dig -1 // buyer: account
	acct_params_get AcctAuthAddr
	assert
	replace3
	byte 0x6172744e4654 // "artNFT"
	frame_dig -2 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	dup
	box_del
	pop
	swap
	box_put

	// contracts/aurally.algo.ts:301
	// assert(this.artNFTs(nftIpfs).value.owner !== buyer.authAddr)
	byte 0x6172744e4654 // "artNFT"
	frame_dig -2 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 40 32
	frame_dig -1 // buyer: account
	acct_params_get AcctAuthAddr
	assert
	!=
	assert

	// contracts/aurally.algo.ts:303
	// this.pay(this.artNFTs(nftIpfs).value.owner, this.soundNFTs(nftIpfs).value.price)
	byte 0x736f756e644e4654 // "soundNFT"
	frame_dig -2 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 32 8
	btoi
	byte 0x6172744e4654 // "artNFT"
	frame_dig -2 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 40 32
	callsub pay

if3_end:
	// contracts/aurally.algo.ts:306
	// return true;
	int 1
	byte 0x00
	int 0
	uncover 2
	setbit
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// transferNFT(bool,string,address,account)bool
//
// // // Transfer an NFT
abi_route_transferNFT:
	// isSoundNFT: bool
	txna ApplicationArgs 4
	dup
	len
	int 1
	==
	assert
	int 0
	getbit

	// nftIpfs: string
	txna ApplicationArgs 3
	extract 2 0

	// receiver: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// sender: account
	txna ApplicationArgs 1
	btoi
	txnas Accounts

	// execute transferNFT(bool,string,address,account)bool
	callsub transferNFT
	int 1
	return

transferNFT:
	proto 4 0

	// if4_condition
	// contracts/aurally.algo.ts:312
	// isSoundNFT ? this.soundNFTs(nftIpfs).exists : this.artNFTs(nftIpfs).exists
	frame_dig -4 // isSoundNFT: bool
	bz ternary1_false
	byte 0x736f756e644e4654 // "soundNFT"
	frame_dig -3 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_len
	swap
	pop
	b ternary1_end

ternary1_false:
	byte 0x6172744e4654 // "artNFT"
	frame_dig -3 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_len
	swap
	pop

ternary1_end:
	bz if4_else

	// if4_consequent
	// contracts/aurally.algo.ts:313
	// this.soundNFTs(nftIpfs).value.owner = receiver.authAddr
	byte 0x736f756e644e4654 // "soundNFT"
	frame_dig -3 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get
	assert
	store 255 // full array
	load 255 // full array
	int 46
	frame_dig -2 // receiver: address
	acct_params_get AcctAuthAddr
	assert
	replace3
	byte 0x736f756e644e4654 // "soundNFT"
	frame_dig -3 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	dup
	box_del
	pop
	swap
	box_put
	b if4_end

if4_else:
	// contracts/aurally.algo.ts:315
	// this.artNFTs(nftIpfs).value.owner = receiver.authAddr
	byte 0x6172744e4654 // "artNFT"
	frame_dig -3 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get
	assert
	store 255 // full array
	load 255 // full array
	int 40
	frame_dig -2 // receiver: address
	acct_params_get AcctAuthAddr
	assert
	replace3
	byte 0x6172744e4654 // "artNFT"
	frame_dig -3 // nftIpfs: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	dup
	box_del
	pop
	swap
	box_put

if4_end:
	// contracts/aurally.algo.ts:318
	// return true;
	int 1
	byte 0x00
	int 0
	uncover 2
	setbit
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// voteOnProposal(uint64,bool,account)bool
//
// // // Voting logic
abi_route_voteOnProposal:
	byte 0x; dupn 2 // push empty bytes to fill the stack frame for this subroutine's local variables

	// propID: uint64
	txna ApplicationArgs 3
	btoi

	// vote: bool
	txna ApplicationArgs 2
	dup
	len
	int 1
	==
	assert
	int 0
	getbit

	// voter: account
	txna ApplicationArgs 1
	btoi
	txnas Accounts

	// execute voteOnProposal(uint64,bool,account)bool
	callsub voteOnProposal
	int 1
	return

voteOnProposal:
	proto 6 0

	// contracts/aurally.algo.ts:324
	// proposalExists = this.aurallyDaoProposals(propID).exists
	byte 0x70726f706f73616c73 // "proposals"
	frame_dig -3 // propID: uint64
	itob
	concat
	box_len
	swap
	pop
	frame_bury -4 // proposalExists: uint64

	// contracts/aurally.algo.ts:325
	// assert(proposalExists)
	frame_dig -4 // proposalExists: uint64
	assert

	// if5_condition
	// contracts/aurally.algo.ts:327
	// vote === true
	frame_dig -2 // vote: bool
	int 1
	==
	bz if5_else

	// if5_consequent
	// contracts/aurally.algo.ts:328
	// a = this.aurallyDaoProposals(propID).value.yesVotes
	byte 0x70726f706f73616c73 // "proposals"
	frame_dig -3 // propID: uint64
	itob
	concat
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	frame_bury -5 // a: uint64

	// contracts/aurally.algo.ts:329
	// this.aurallyDaoProposals(propID).value.yesVotes = a + 1
	byte 0x70726f706f73616c73 // "proposals"
	frame_dig -3 // propID: uint64
	itob
	concat
	box_get
	assert
	store 255 // full array
	load 255 // full array
	int 8
	frame_dig -5 // a: uint64
	int 1
	+
	itob
	replace3
	byte 0x70726f706f73616c73 // "proposals"
	frame_dig -3 // propID: uint64
	itob
	concat
	dup
	box_del
	pop
	swap
	box_put
	b if5_end

if5_else:
	// contracts/aurally.algo.ts:331
	// b = this.aurallyDaoProposals(propID).value.noVotes
	byte 0x70726f706f73616c73 // "proposals"
	frame_dig -3 // propID: uint64
	itob
	concat
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 16 8
	btoi
	frame_bury -6 // b: uint64

	// contracts/aurally.algo.ts:332
	// this.aurallyDaoProposals(propID).value.yesVotes = b + 1
	byte 0x70726f706f73616c73 // "proposals"
	frame_dig -3 // propID: uint64
	itob
	concat
	box_get
	assert
	store 255 // full array
	load 255 // full array
	int 8
	frame_dig -6 // b: uint64
	int 1
	+
	itob
	replace3
	byte 0x70726f706f73616c73 // "proposals"
	frame_dig -3 // propID: uint64
	itob
	concat
	dup
	box_del
	pop
	swap
	box_put

if5_end:
	// contracts/aurally.algo.ts:335
	// return true;
	int 1
	byte 0x00
	int 0
	uncover 2
	setbit
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// createProposal(uint64,string,account)bool
abi_route_createProposal:
	// id: uint64
	txna ApplicationArgs 3
	btoi

	// proposalDetails: string
	txna ApplicationArgs 2
	extract 2 0

	// creator: account
	txna ApplicationArgs 1
	btoi
	txnas Accounts

	// execute createProposal(uint64,string,account)bool
	callsub createProposal
	int 1
	return

createProposal:
	proto 3 0

	// contracts/aurally.algo.ts:340
	// assert(this.aurallyNFTOwner(creator.authAddr).exists)
	byte 0x6e66744f776e6572 // "nftOwner"
	frame_dig -1 // creator: account
	acct_params_get AcctAuthAddr
	assert
	concat
	box_len
	swap
	pop
	assert

	// contracts/aurally.algo.ts:343
	// this.aurallyDaoProposals(id).value = {
	//       proposalHash: id + 1,
	//       yesVotes: 0,
	//       noVotes: 0,
	//       details: proposalDetails, // Optionally store proposal details
	//     }
	byte 0x70726f706f73616c73 // "proposals"
	frame_dig -3 // id: uint64
	itob
	concat
	dup
	box_del
	pop
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x001a // initial head offset
	frame_dig -3 // id: uint64
	int 1
	+
	itob
	callsub process_static_tuple_element
	byte 0x0000000000000000
	callsub process_static_tuple_element
	byte 0x0000000000000000
	callsub process_static_tuple_element
	frame_dig -2 // proposalDetails: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	box_put

	// contracts/aurally.algo.ts:349
	// return true;
	int 1
	byte 0x00
	int 0
	uncover 2
	setbit
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// streamNFT(string,address)bool
//
// // // Record a stream and award an Aura token
abi_route_streamNFT:
	byte 0x; dup // push empty bytes to fill the stack frame for this subroutine's local variables

	// ipfslocation: string
	txna ApplicationArgs 2
	extract 2 0

	// owner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute streamNFT(string,address)bool
	callsub streamNFT
	int 1
	return

streamNFT:
	proto 4 0

	// contracts/aurally.algo.ts:354
	// nft = this.soundNFTs(ipfslocation).value
	byte 0x736f756e644e4654 // "soundNFT"
	frame_dig -2 // ipfslocation: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	frame_bury -3 // storage key//nft

	// contracts/aurally.algo.ts:355
	// assert(this.soundNFTs(ipfslocation).exists)
	byte 0x736f756e644e4654 // "soundNFT"
	frame_dig -2 // ipfslocation: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_len
	swap
	pop
	assert

	// contracts/aurally.algo.ts:356
	// assert(nft.owner === owner)
	frame_dig -3 // storage key//nft
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 46 32
	frame_dig -1 // owner: address
	==
	assert

	// contracts/aurally.algo.ts:359
	// currentEarnings = this.aurallyStreamEarnings(owner).value || 0
	byte 0x73747265616d4561726e696e6773 // "streamEarnings"
	frame_dig -1 // owner: address
	concat
	box_get
	assert
	btoi
	dup
	bnz skip_or1
	int 0
	||

skip_or1:
	frame_bury -4 // currentEarnings: uint64

	// contracts/aurally.algo.ts:360
	// this.aurallyStreamEarnings(owner).value = currentEarnings + 1
	byte 0x73747265616d4561726e696e6773 // "streamEarnings"
	frame_dig -1 // owner: address
	concat
	frame_dig -4 // currentEarnings: uint64
	int 1
	+
	itob
	box_put

	// contracts/aurally.algo.ts:361
	// return true;
	int 1
	byte 0x00
	int 0
	uncover 2
	setbit
	byte 0x151f7c75
	swap
	concat
	log
	retsub

getAccountBalance:
	proto 1 1

	// contracts/aurally.algo.ts:366
	// return this.aurallyStreamEarnings(accountAddress.authAddr).value || 0;
	byte 0x73747265616d4561726e696e6773 // "streamEarnings"
	frame_dig -1 // accountAddress: address
	acct_params_get AcctAuthAddr
	assert
	concat
	box_get
	assert
	btoi
	dup
	bnz skip_or2
	int 0
	||

skip_or2:
	retsub

// optInToAsset(asset,account)bool
abi_route_optInToAsset:
	// asset: asset
	txna ApplicationArgs 2
	btoi
	txnas Assets

	// user: account
	txna ApplicationArgs 1
	btoi
	txnas Accounts

	// execute optInToAsset(asset,account)bool
	callsub optInToAsset
	int 1
	return

optInToAsset:
	proto 2 0

	// contracts/aurally.algo.ts:371
	// sendAssetTransfer({
	//       assetReceiver: user.authAddr,
	//       xferAsset: asset,
	//       assetAmount: 0,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/aurally.algo.ts:372
	// assetReceiver: user.authAddr
	frame_dig -1 // user: account
	acct_params_get AcctAuthAddr
	assert
	itxn_field AssetReceiver

	// contracts/aurally.algo.ts:373
	// xferAsset: asset
	frame_dig -2 // asset: asset
	itxn_field XferAsset

	// contracts/aurally.algo.ts:374
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/aurally.algo.ts:376
	// return true;
	int 1
	byte 0x00
	int 0
	uncover 2
	setbit
	byte 0x151f7c75
	swap
	concat
	log
	retsub

create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match abi_route_createApplication
	err

call_NoOp:
	method "createSoundNFT(account,string,string,string,uint64,string,string,string,string,uint64,uint64,string,string)bool"
	method "createArtNFT(account,(string,uint64,string,uint64,string,string,uint64,uint64,address,bool),string,string)bool"
	method "startAuction(string,string,uint64)void"
	method "bidOnArtAuction(account,string,uint64)void"
	method "endArtAuction(account,string)void"
	method "purchaseNFT(account,string,bool)bool"
	method "transferNFT(account,address,string,bool)bool"
	method "voteOnProposal(account,bool,uint64)bool"
	method "createProposal(account,string,uint64)bool"
	method "streamNFT(address,string)bool"
	method "optInToAsset(account,asset)bool"
	txna ApplicationArgs 0
	match abi_route_createSoundNFT abi_route_createArtNFT abi_route_startAuction abi_route_bidOnArtAuction abi_route_endArtAuction abi_route_purchaseNFT abi_route_transferNFT abi_route_voteOnProposal abi_route_createProposal abi_route_streamNFT abi_route_optInToAsset
	err

process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub